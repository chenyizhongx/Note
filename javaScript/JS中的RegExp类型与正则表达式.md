## 一 创建一个正则表达式

ECMAScript通过`RegExp` 类型来支持正则表达式。
基本模式为：
`var expression = / pattern / flags;`  
可以使用以下两种方法之一构建一个正则表达式

    var regex = /ab + c/;

    var regex = /^[a-zA-Z]+[0-9]*\W?_$/gi;
或者调用`RegExp` 对象的构造函数，

    let regex = new RegExp("ab+c");

    let regex = new RegExp("/^[a-zA-Z]+[0-9]*\W?_$/","gi");
每个正则表达式都可带有一个或者多个标志，用以表明正则表达式的行为。

- **g** :  表示全局（global）模式，该模式将应用于所有的字符串，而非在发现第一个匹配项的时候就立即停止；
- **i**  :  表示不区分大小写模式，即在匹配项的时候忽略模式于字符串的大小写；
- **m**：表示多行模式，即在到达一行文本末尾的时候会继续查找下一行
## 二 编写一个正则表达式的模式
#### 1）元字符
常用的元字符

代码 | 说明 
:-----:|:------:
. |    匹配除换行符之外的任意字符
\w | 匹配字母或数字或下划线或汉字
\s | 匹配任意的空白字符
\d | 匹配数字
\b | 匹配单词的开始或结束
^ | 匹配字符串的开始
$ | 匹配字符串的结束

#### 2) 反义
有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义：

常用的反义代码

代码/语法 | 说明     
:-----:|:------:
 \W | 匹配任意不是字母，数字，下划线，汉字的字符
\S | 匹配任意不是空白符的字符
\D | 匹配任意非数字的字符
\B | 匹配不是单词开头或结束的位置
[^x] | 匹配除了x以外的任意字符
[^aeiou] | 匹配除了aeiou这几个字母以外的任意字符

例子：   
    \S+匹配不包含空白符的字符串。
     <a[^>]+>匹配用尖括号括起来的以a开头的字符串。


#### 3）重复
常用的限定符

代码/语法 | 说明 
:-----:|:------:
* | 重复零次或更多次
+ | 重复一次或者更多次
? | 重复零次或一次
{n} | 重复 n 次
{n,} | 重复 n 次或更多次
{n,m}| 重复n到m次

#### 4) 字符类
想匹配**没有预定义元字符**的字符集合，可以在方括号中列出它们。例如`[aeiou] `匹配任何一个英文元音字母，`[.?!]` 匹配标点符号(.或?或!)。

#### 5) 字符转义
如果想查找元字符本身的话, 可以使用 `\` 来取消这些字符的特殊意义。。当然，要查找`\`本身，就要使用`\\`.

#### 6）贪婪与懒惰
当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配**尽可能多**的字符。以这个表达式为例：`a.*b`，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为 **贪婪匹配** 。（默认的匹配方式）

有时，我们更需要**懒惰匹配**，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号`?`。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。
例子：
`a.*?b`匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。 

懒惰的限定符
代码/语法 | 说明 
:-----:|:------:
*? | 重复任意次，但尽可能少重复
+? | 重复1次或更多次，但尽可能少重复
?? | 重复0次或1次，但尽可能少重复
{n,m}?? | 重复0次或1次，但尽可能少重复
{n,}? 重复n次以上，但尽可能少重复

#### 7) 分支条件
正则表达式里的**分枝条件**指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用 `|` 把不同的规则分隔开。

例如：
`0\d{2}-\d{8}|0\d{3}-\d{7}`  这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。

`\(0\d{2}\)[- ]?\d{8}|0\d{2}[- ]?\d{8}`  这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。

#### 8）分组
重复单个字符直接在字符后面加上限定符就行了，但如果想要重复多个字符又该怎么办？可以用**小括号**来指定**子表达式**(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。

`(\d{1,3}\.){3}\d{1,3}`是一个简单的IP地址匹配表达式。要理解这个表达式，可以按下列顺序分析它：`\d{1,3}`匹配1到3位的数字，`(\d{1,3}\.){3}`匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字`(\d{1,3})`。

#### 9）后向引用
使用小括号指定一个子表达式后，**匹配这个子表达式的文本**(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个**组号**，规则是：**从左向右**，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。  

**后向引用**用于重复搜索前面某个分组匹配的文本。例如，\1代表分组1匹配的文本。例如：
`\b(\w+)\b\s+\1\b`可以用来匹配重复的单词。像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是*单词开始处和结束处之间的多于一个的字母或数字* (`\b(\w+)\b`),这个单词会被捕获到编号为1的分组中，然后是*1个或几个空白符*(`\s+`)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(`\1`)。

组号分配的其他情况：   

- 分组0对应整个正则表达式
- 实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号
- 可以使用`(?:exp)`这样的语法来剥夺一个分组对组号分配的参与权．



![常用的分组语法](https://upload-images.jianshu.io/upload_images/11428632-d512cb177e5da05b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
#### 10）零宽断言
用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像`\b,^,$`那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，称为零宽断言。

`(?=exp)`也叫**零宽度正预测先行断言**，它断言自身出现的位置的后面能匹配表达式`exp`。比如`\b\w+(?=ing\b)`，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I'm singing while you're dancing.时，它会匹配sing和danc。

`(?<=exp)`也叫**零宽度正回顾后发断言**，它断言自身出现的位置的前面能匹配表达式`exp`。比如`(?<=\bre)\w+\b`会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。

#### 11) 负向零宽断言

前面我们提到过怎么查找**不是某个字符或不在某个字符类**里的字符的方法(反义)。但是如果我们只是想要**确保某个字符没有出现，但并不想去匹配它**时怎么办？例如，如果我们想查找这样的单词--它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：

`\b\w*q[^u]\w*\b`匹配包含后面不是字母`u`的字母`q`的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果`q`出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为`[^u]`总要匹配一个字符，所以如果`q`是单词的最后一个字符的话，后面的`[^u]`将会匹配`q`后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的`\w*\b`将会匹配下一个单词，于是`\b\w*q[^u]\w*\b`就能匹配整个Iraq fighting。负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。现在，我们可以这样来解决这个问题：`\b\w*q(?!u)\w*\b`。

**零宽度负预测先行断言** `(?!exp)`，断言此位置的后面不能匹配表达式`exp`。例如：`\d{3}(?!\d)`匹配三位数字，而且这三位数字的后面不能是数字；`\b((?!abc)\w)+\b`匹配不包含连续字符串abc的单词。

同理，我们可以用`(?<!exp)`,零宽度负回顾后发断言来断言此位置的前面不能匹配表达式`exp：(?<![a-z])\d{7}`匹配前面不是小写字母的七位数字。

请详细分析表达式`(?<=<(\w+)>).*(?=<\/\1>)`，这个表达式最能表现零宽断言的真正用途。
一个更复杂的例子：`(?<=<(\w+)>).*(?=<\/\1>)`匹配不包含属性的简单HTML标签内里的内容。`(?<=<(\w+)>)`指定了这样的前缀：被尖括号括起来的单词(比如可能是<b>)，然后是`.*`(任意的字符串),最后是一个后缀`(?=<\/\1>)`。注意后缀里的\/，它用到了前面提过的字符转义；`\1`则是一个反向引用，引用的正是捕获的第一组，前面的`(\w+)`匹配的内容，这样如果前缀实际上是`<b>`的话，后缀就是`</b>`了。整个表达式匹配的是`<b>`和`</b>`之间的内容(再次提醒，不包括前缀和后缀本身)。

#### 12) 注释
小括号的另一种用途是通过语法`(?#comment)`来包含注释。例如：`2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)`。

## 三 使用正则表达式
正则表达式可以被用于[`RegExp`](https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/RegExp "RegExp")的[`exec`](https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/RegExp/exec "exec")和[`test`](https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/RegExp/test "test")方法以及 [`String`](https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/String "String")的[`match`](https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/String/match "match")、[`replace`](https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/String/replace "zh-CN/docs/JavaScript/Reference/Global_Objects/String/replace")、[`search`](https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/String/search "search")和[`split`](https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/String/split "split")方法。

使用正则表达式的方法

方法 | 描述
:-----:|:------
exec |  一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回`null`）。
test |  一个在字符串中测试是否匹配的RegExp方法，它返回true或false。
match | 一个在字符串中执行查找匹配的String方法，它返回一个数组或者在未匹配到时返回null。
search | 一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1
replace | 一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串
split | 一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的String方法。

    // 下面这个姓名字符串包含了多个空格和制表符，
    // 且在姓和名之间可能有多个空格和制表符。
    var names = "Harry Trump ;Fred Barney; Helen Rigby ; Bill Abel ; Chris Hand ";
    
    var output = ["---------- Original String\n", names + "\n"];
    
    // 准备两个模式的正则表达式放进数组里。
    // 分割该字符串放进数组里。
    
    // 匹配模式：匹配一个分号及紧接其前后所有可能出现的连续的不可见符号。
    var pattern = /\s*;\s*/;
    
    // 把通过上述匹配模式分割的字符串放进一个叫做nameList的数组里面。
    var nameList = names.split(pattern);
    
    // 新建一个匹配模式：匹配一个或多个连续的不可见字符及其前后紧接着由
    // 一个或多个连续的基本拉丁字母表中的字母、数字和下划线组成的字符串
    // 用一对圆括号来捕获该模式中的一部分匹配结果。
    // 捕获的结果稍后会用到。
    pattern = /(\w+)\s+(\w+)/;
    
    // 新建一个数组 bySurnameList 用来临时存放正在处理的名字。
    var bySurnameList = [];
    
    // 输出 nameList 的元素并且把 nameList 里的名字
    // 用逗号接空格的模式把姓和名分割开来然后存放进数组 bySurnameList 中。
    //
    // 下面的这个替换方法把 nameList 里的元素用 $2, $1 的模式
    // （第二个捕获的匹配结果紧接着一个逗号一个空格然后紧接着第一个捕获的匹配结果）替换了
    // 变量 $1 和变量 $2 是上面所捕获的匹配结果。
    
    output.push("---------- After Split by Regular Expression");
    
    var i, len;
    for (i = 0, len = nameList.length; i < len; i++){
      output.push(nameList[i]);
      bySurnameList[i] = nameList[i].replace(pattern, "$2, $1");
    }
    
    // 输出新的数组
    output.push("---------- Names Reversed");
    for (i = 0, len = bySurnameList.length; i < len; i++){
      output.push(bySurnameList[i]);
    }
    
    // 根据姓来排序，然后输出排序后的数组。
    bySurnameList.sort();
    output.push("---------- Sorted");
    for (i = 0, len = bySurnameList.length; i < len; i++){
      output.push(bySurnameList[i]);
    }
    
    output.push("---------- End");
    
    console.log(output.join("\n"));
