## 一 理解对象
#### 1）属性类型
ECMAScript中有两种属性：数据属性和访问器属性。   
1. **数据属性**       
        数据属性包含一个数据值的位置，在这个位置可以读取和写入值，数据属性有四种描述其行为的特性。  

      - [ [ Configurable ] ]:  表示能否通过delete删除属性从而重新定义属性，直接在对象上定义属性，则默认值为 true
      - [ [ Enumerable ] ]:  表示能否通过for-in循环访问属性，直接在对象上定义属性，则默认值为 true
      - [ [ Writable ] ]:   表示能否修改属性的值，  直接在对象上定义属性，则默认值为 true
      - [ [ Value ] ]:   包含这个属性的数据值。这个特性的默认值为 undefined。

要修改默认值的属性, 可以使用Object.defineProperty()  方法。
把configurable设置成false，表示不能从对象中删除属性，并且一旦把属性定义为不可配置的，就不能把它变为可配置的了。

    var person = {};
    Object.defineProperty(person, "name", {
      configurable: false,
      value: "zhong"
    });
    // 抛出错误
    Object.defineProperty(person, "name", {
      configurable: true,
      value: "zhong"
    }); 


注意：在调用 Object.defineProperty()  方法创建一个新的属性时如果不指定，configurable ,  enumerable  和 writable 特性的默认值都是false。
  
2. **访问器属性**       
访问器属性不包括数据值：它们包含一对getter和setter函数（非必需）访问器属性也有四个属性值：
      - [ [ Configurable ] ]:  表示能否通过delete删除属性从而重新定义属性，直接在对象上定义属性，则默认值为 true
      - [ [ Enumerable ] ]:  表示能否通过for-in循环访问属性，直接在对象上定义属性，则默认值为 true
      - [ [ Get ] ]:   在读取属性时调用的函数，默认值为 undefined 
      - [ [ Set ] ]:   在写入属性时调用的函数，默认值为 undefined
访问器属性不能直接定义，必须使用 Object.defineProperty() 来定义。

            var book = {
              _year: 2004,
              edition: 1
            };

            Object.defineProperty(book, "year", {
                get: function() {
                    return this._year;
                },
                set: function(newValue) {
                    if (newValue > 2004) {
                         this._year = newValue;
                         this.edition += newValue - 2004;
                     }
                }
            });

            book.year = 2007;
            console.log(book.edition);      // 4
_year前面的下划线用于表示只能通过对象方法访问的属性。上面是使用访问器的常见方式，即设置一个属性的值会导致其他属性的值发生变化。

#### 2) 定义多个属性 和读取属性的特性

Object.defineProperties() 这个方法可以通过描述符一次定义多个属性。
这个方法接收两个对象参数：第一个是要添加和修改属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。     

getOwnPropertyDescriptor() 方法可以取得给定属性的描述符，这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。



    var book = {};
    
    Object.defineProperties(book, {
    
      //数据属性
      _year: {
        writable: true,
        value: 2004
      },
    
      edition: {
        writable: true,
        value: 1
      },
    
      //访问器属性
      year: {
        get: function () {
          return this._year;
        },
    
        set: function () {
          if (newValue > 2004) {
            this._year = newValue;
            this.edition += newValue -2004;
          }
        }
      }
    });
    
    var descriptor = Object.getOwnPropertyDescriptor(book, "_year");
    console.log(descriptor.value);     // 2004
    console.log(descriptor.configurable);      //  fales
    console.log(typeof descriptor.get);     //  undefined
    
    var descriptor = Object.getOwnPropertyDescriptor(book, "year");
    console.log(descriptor.value);          //   undefined
    console.log(descriptor.enumerable);   //  false 
    console.log(typeof descriptor.get);       //   "function"

      
## 二创建对象
#### 1) 工厂模式
    function createPerson(name, age, job) {
      var o = new Object();
      o.name = name;
      o.age = age;
      o.job = job;
      o.sayName = function() {
        alert(this.name);
      };
      return o;
    }
    
    var person1 = createPerson("hehehe","22","teacher");
工厂模式虽然解决了创建多个相似对象的问题，却不能解决对象识别的问题（即怎么样知道一个对象的类型）

#### 2) 构造函数模式

    function Person(name, age, job){
      this.name = name;
      this.job = job;
      this.sayName = function() {
        alert(this.name);
      };
    }
    
    //当作构造函数来使用
    var person1 = new Person("Ngrad", 22, "worker");
    var person2 = new Person("zhong", 33, "teacher");
    
    console.log(person1.constructor == Person);   //true
    console.log(person2.constructor == Person);     //true

1. **将构造函数当作函数**


任何函数，只要通过 new 操作符来调用，那它就可以作为构造函数      
 


    var person1 = new Person("Ngrad", 22, "worker");       //当作构造函数来使用
    var person2 = new Person("zhong", 33, "teacher");
    
    console.log(person1.constructor == Person);   //true
    console.log(person2.constructor == Person);     //true


    //作为普通函数来使用
    Person("John", 48, "Doctor");     //添加到window
    window.sayName();     
    
    //在另一个对象的作用域中调用
    var o = new Objecct();
    Person.call(o, "John", 48, "Doctor");
    o.sayName();  


  2.**构造函数的问题**     

主要问题是每个方法都要在每个实例上重新创建一遍同名的方法不是同个Function的实例。在ES中函数是对象，因此没定义一个函数就是实例化了一个对象。
因为这种构造方式会导致不同实例上的同名函数是不相等的创建两个完成同样任务的实例没有必要，我们可以通过把函数定义转移到构造函数外面来解决这个问题。


    function Person(name, age, job){
      this.name = name;
      this.job = job;
      this.sayName = sayName;
    }
    
    function sayName() {
      alert(this.name);
    }

    var person1 = new Person("Ngrad", 22, "worker");
    var person2 = new Person("zhong", 33, "teacher");

因为js解析器在向执行环境中加载数据的时候会先加载函数声明，故Person中的sayName就是一个指向函数的指针。因此person1和person2就共享了同一个sayName()函数。    
定义方法需要定义多个全局变量，使得我们自定义的引用类型毫无封装性可言。况且一个全局函数只能被某个对象调用，这让全局作用域有些名不副实。这些问题可以通过原型来解决。

#### 3) 原型模式
我们创建的每一个函数都有一个 prototype (原型) 属性，这个属性是一个指针，指向一个对象，而这个对象包含可以由特定类型的所有实例共享的所有属性和方法。    
即prototype就是通过调用函数而创建的那个对象实例的原型对象。    
使用原型对象的的好处是**可以让所有的对象实例共享它包含所包含的属性和方法。**  即不必在对象实例中定义对象实例的信息，而是将这些信息直接添加到原型对象中。

    function Person() {
    }
    
    Person.prototype.name = "Nikou";
    Person.prototype.age = 29;
    Person.prototype.job = "Engineer";
    Person.prototype.sayName = function() {
      alert(this.name);
    };
    
    var person1 = new Person();
    person1.sayName();
    
    var person2 = new Person();
    person2.sayName();
    
    alert(person1.sayName == person2.sayName);    // true  

1. **理解原型对象** 

只要创建了一个新函数，就会有一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。在默认的情况下，所有的原型对象会自动获得一个 constructor (构造函数)属性，这个属性是一个指向 prototype 属性所在函数的指针。
![原型对象](https://upload-images.jianshu.io/upload_images/11428632-2bb77bfa928d8259.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
  
当代码读取某个对象的某个属性时，会先搜索对象实例本身，如果搜索不到，就原型对象的属性。也就是说，实例中的属性会屏蔽掉原型中的同名属性。     
换句话说添加一个属性会阻止我们访问原型中的属性，但不会修改它的属性。即使属性设置为 null ，也不会恢复其指向原型中的链接。但我们可以通过 delete操作符来完全删除实例属性。


    function Person() {
    }
    
    Person.prototype.name = "Nikou";
    Person.prototype.age = 29;
    Person.prototype.job = "Engineer";
    Person.prototype.sayName = function() {
      alert(this.name);
    };
    
    var person1 = new Person();
    var person2 = new Person();
    
    alert(person1.hasOwnProperty("name"));   //false
    
    person1.name = "zhong";
    console.log(person1.name);        // "zhong"    原型
    console.log(person2.name);        //  "Nikou"   原型
    alert(person1.hasOwnProperty("name"));    //true
    
    delete person1.name;
    console.log(person1.name);     //  "Nikou"来自原型

使用hasOwnProperty() 方法可以检测一个属性是否存在与实例中，这个方法只在给定属性存在于实例中，才会返回true。代码见上方。    

2. **原型与in操作符**            
      有两种方式使用 in 操作符：单独使用和在 for-in 循环中使用。
      - 单独使用  
          单独使用时，in 操作符会在通过对象能够访问的给定的属性时返回 true，**无论该属性时存在于实例中还是原型中。**
同时使用 in 和  hasOwnProperty 可确定属性的位置。    
由于in 操作符只要通过对象能够访问到的属性就会返回true， hasOwnProperty() 只在属性存在于实例中时才返回 true 。 因此只要 in操作符返回true 而hasOwnProperty 返回false() 就可以确定属性时原型中的属性。  

            function judge(object, name) {
                return !object.hasOwnProperty(name) && (name in object);
            }


   - for - in 中使用  
      使用for - in 循环时，返回的是所有能够通过对象访问的，可枚举的（enumerated）属性。**其中既包括存在于原型中的属性，也包括存在于实例中的属性**。

要取得对象上所有可枚举的实例属性，可以使用ES５中的Ｏbject.key() 方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。

    function Person() {
    }
    
    Person.prototype.name = "Nikou";
    Person.prototype.age = 29;
    Person.prototype.job = "Engineer";
    Person.prototype.sayName = function() {
      alert(this.name);
    };
    
    var keys = Object.keys(Person.prototype);
    console.log(keys);        //  "name, age, job, sayName"
    
    var p1 = new Person();
    p1.name = "Rob";
    p1.age = 31;
    var p1key = Object.keys(p1);
    console.log(p1key);       // "name, age"

使用Object.getOwnPropertyNames() 可以得到所有的实例属性无论它是否可以枚举。
注意： 原生的constructor属性是不可枚举的。    

3. **原型的动态性**  

调用构造函数会为实例添加一个指向最初原型的[ [ Prototype ] ] 指针，而把原型修改为另一个对象就等于切断了构造函数与最初原型之间的联系。实例中的指针指向原型 ，而不指向构造函数。


    function Person() {
    }
    
    var friend = new Person();
    
    Person.prototype = {
      constructor: Person,
      name: "Nikou",
      age: 44,
      job: "Engineer",
      sayName: function() {
        alert(this.name);
      }
    };
    
    friend.sayName();     //error
4. **原型对象的问题**       

      最大的问题是由其共享的本性决定的。实例一般要有属于自己的全部属性的。



        function Person() {
        }
    
        Person.prototype = {
            name: "NIdfes",
            age: 25,
            job: "teacher",
            friend: ["Sheliby", "Court"],
            sayName: function() {
               alert(this.name);
            }
        };
    
        var person1 = new Person();
        var person2 = new Person();
    
        person1.friend.push("Van");
    
        alert(person1.friend);       //  "Sheliby, Court，Van"
        alert(person2.friend);          //  "Sheliby, Court，Van"
        alert(person1.friend === person2.friend);    // true
#### 4) 组合使用构造函数和原型模式

每个实例都有自己的一份实例属性的副本，但同时又共享着对方法的使用。
这是定义引用类型的默认模式。

    function Person(name, age, job) {
      this.name = name;
      this.age = age;
      this.job = job;
      this.friend = ["Sheliby", "Court"];
    }
    
    Person.prototype = {
      constructor: Person,
      sayName: function() {
        alert(this.name);
      }
    }
    
    var person1 = new Person("Ngrad", 22, "worker");
    var person2 = new Person("zhong", 33, "teacher");
    
    person1.friend.push("Van");
    
    alert(person1.friend);          //  "Sheliby, Court，Van"
    alert(person2.friend);          //  "Sheliby, Court"
    alert(person1.friend === person2.friend);          //false
    alert(person1.sayName === person2.sayName);      //  true
#### 5) 动态原型模式
它把所有的信息封装在构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下）又保持了同时使用构造函数和原型的优点。

    function Person(name, age, job) {
      //属性
      this.name = name;
      this.age = age;
      this.job = job;
      
      //方法
      if (typeof this.sayName != "function") {
    
        person.prototype.sayName = function() {
          alert(this.name);
        };
      }
    }
#### 6) 寄生构造函数模式
基本思想：创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。 不常用

    function Person(name, age, job) {
      var o = new Object();
      o.name = name;
      o.age = age;
      o.job = job;
      o.sayName = function() {
        alert(this.name);
      };
      return o;
    }
    
    var friend = new Person("Ngrad", 22, "worker");
    friend.sayName();    //  " Ngrad "
#### 7) 稳妥构造函数模式
新创建的对象实例方法不引用this； 不使用new操作符调用构造函数。

## 三 继承
#### 1) 原型链